<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TrueNAS Dashboard</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='icons/favicon.png') }}">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    />
    <style>
      .liquid-glass {
          /* Distortion Filter from User Request */
          backdrop-filter: blur(4px) url(#liquid_glass_filter);
          -webkit-backdrop-filter: blur(4px) url(#liquid_glass_filter);
          
          /* Glassy Shadows & Highlights (Adjusted for Dark Mode) */
          box-shadow:
            inset 0 1px 0 rgba(255,255,255,0.2),
            inset 0 -1px 0 rgba(0,0,0,0.3),
            inset 6px 6px 16px rgba(255,255,255,0.05),
            0 10px 28px rgba(0,0,0,0.5);
          
          /* Semi-transparent Background */
          background: rgba(30, 41, 59, 0.4);
      }
    </style>
  </head>
  <body class="bg-slate-950 text-slate-100 h-screen flex overflow-hidden">
    <!-- SVG Filter for Liquid Effect -->
    <svg width="0" height="0" style="position:absolute;left:-9999px;top:-9999px">
      <defs>
        <filter id="liquid_glass_filter">
          <feTurbulence type="fractalNoise" baseFrequency="0.003" numOctaves="2" seed="7" result="noise"/>
          <feGaussianBlur in="noise" stdDeviation="1.2" result="map"/>
          <feDisplacementMap in="SourceGraphic" in2="map" scale="110" xChannelSelector="R" yChannelSelector="G"/>
        </filter>
      </defs>
    </svg>

    <!-- Background Decoration -->
    <div id="bg-ip-decoration" class="fixed top-[-1rem] right-[-1rem] font-black text-slate-700 select-none pointer-events-none z-0 text-[10rem] whitespace-nowrap opacity-40 blur-[3px] leading-none">
       <!-- IP injected here -->
    </div>

    <!-- Left Sidebar: App Icons -->
    <aside class="w-20 liquid-glass flex flex-col items-center py-6 gap-4 overflow-y-auto hidden-scrollbar z-10 relative">
      <div class="mb-4 shrink-0">
        <a href="/" class="text-cyan-400 hover:text-cyan-300 transition" title="Dashboard">
          <i class="fa-solid fa-server text-3xl drop-shadow-lg"></i>
        </a>
      </div>
      
      {% for group in apps %}
      <!-- Group Container -->
      <div class="flex flex-col items-center gap-2 w-full px-2 relative" id="group-{{ loop.index }}">
         <!-- Folder Button -->
         <button onclick="toggleGroup('list-{{ loop.index }}', this)" 
                 class="w-12 h-12 bg-slate-800/60 rounded-xl flex items-center justify-center hover:bg-slate-700 hover:scale-105 transition-all duration-300 cursor-pointer text-slate-400 hover:text-white group border border-transparent hover:border-slate-500/50 relative shrink-0 z-20 folder-btn">
             <i class="fa-solid {{ group.icon }} text-xl {{ group.color }} transition-colors"></i>
         </button>

         <!-- Expandable List -->
         <div id="list-{{ loop.index }}" class="flex flex-col gap-3 items-center w-full overflow-hidden transition-all duration-300 ease-in-out max-h-0 opacity-0 relative z-10 app-list-container">
            {% for app in group.apps %}
            <a href="http://{{ truenas_ip }}:{{ app.port }}" target="_blank" 
                data-tooltip="{{ app.name }}"
                class="w-12 h-12 bg-slate-700/40 rounded-xl flex items-center justify-center hover:bg-slate-600 hover:scale-110 transition-all duration-200 cursor-pointer group border border-transparent hover:border-slate-500/30 relative shrink-0">
                
                <!-- Icon or Fallback -->
                <img src="{{ url_for('static', filename='icons/' + app.icon) }}" 
                    alt="{{ app.name }}" 
                    class="w-10 h-10 object-contain opacity-85 group-hover:opacity-100 transition-all duration-300 filter grayscale group-hover:grayscale-0 pointer-events-none"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                
                <div class="hidden w-full h-full items-center justify-center text-[9px] font-bold text-slate-300 group-hover:text-white leading-tight text-center px-0.5 animate-pulse pointer-events-none">
                    {{ app.name[:3] }}
                </div>
            </a>
            {% endfor %}
            <div class="w-8 h-px bg-white/10 my-1"></div>
         </div>
      </div>
      {% endfor %}
      
      <!-- Spacer for scroll -->
      <div class="h-4 shrink-0"></div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 flex p-6 gap-6">
      
      <!-- Middle-Left Column: Storage (Donuts) -->
      <section class="w-3/12 flex flex-col gap-6 h-full">
        <!-- Storage Container -->
        <div class="flex-1 liquid-glass rounded-2xl p-6 flex flex-col justify-around items-center" id="storage-container">
           <!-- Placeholder (will be populated by JS) -->
           <div class="text-slate-500 animate-pulse">Loading Storage...</div>
        </div>
      </section>

      <!-- Right Column: Specs & Metrics -->
      <section class="w-9/12 flex flex-col gap-6 h-full">
        
        <!-- Top Half: Specs & HDD Status -->
        <div class="h-1/2 flex gap-6">
          
          <!-- Specs (Left - Smaller) -->
          <div class="w-4/12 liquid-glass rounded-2xl p-6 overflow-auto flex flex-col">
            <div class="flex items-center justify-between mb-4">
              <h2 class="text-xl font-bold text-slate-200"><i class="fa-solid fa-circle-info mr-2 text-cyan-400"></i>Server Specs</h2>
              <!-- Removed Uptime from header -->
            </div>
            
            <div class="prose prose-invert prose-sm max-w-none flex-1">
              <!-- Example Editable Content Area -->
              <div contenteditable="true" class="outline-none focus:ring-1 focus:ring-cyan-500/50 rounded p-2 -m-2">
                <h3 class="text-lg font-semibold text-slate-300">TrueNAS Scale</h3>
                <ul class="list-disc pl-4 text-slate-400 space-y-1 mt-2">
                  <li><strong>CPU:</strong> {{ spec_cpu }}</li>
                  <li><strong>RAM:</strong> {{ spec_ram }}</li>
                  <li><strong>Pool 1:</strong> {{ spec_pool1 }}</li>
                  <li><strong>Pool 2:</strong> {{ spec_pool2 }}</li>
                </ul>
              </div>
            </div>
            
            <!-- Uptime moved to bottom -->
            <div class="mt-auto pt-4 border-t border-white/10 text-xs text-slate-500 text-right" id="uptime-display">
                Uptime: --
            </div>
          </div>

          <!-- Drive Status (Right - Wider, Split HDD/SSD) -->
          <div class="w-8/12 liquid-glass rounded-2xl p-6 relative flex flex-col">
               <div class="flex items-center justify-between mb-4 shrink-0">
                   <h2 class="text-xl font-bold text-slate-200"><i class="fa-solid fa-temperature-half mr-2 text-rose-400"></i>Drive Status</h2>
               </div>
               
               <!-- Headers -->
               <div class="flex gap-4 mb-2 text-xs font-bold text-slate-500 uppercase tracking-wider shrink-0">
                   <div class="w-1/2 pl-2">HDD</div>
                   <div class="w-1/2 pl-2 border-l border-slate-700/50">SSD / NVMe</div>
               </div>

               <!-- Scrollable Content -->
               <div class="flex-1 overflow-y-auto hidden-scrollbar">
                   <div class="flex gap-4 min-h-full">
                       <!-- HDD Column -->
                       <div class="w-1/2 flex flex-col gap-3" id="hdd-list">
                           <!-- JS Populated -->
                       </div>
                       
                       <!-- SSD Column -->
                       <div class="w-1/2 flex flex-col gap-3 border-l border-slate-700/50 pl-4" id="ssd-list">
                           <!-- JS Populated -->
                       </div>
                   </div>
               </div>
          </div>
        </div>

        <!-- Bottom Half: Metrics -->
        <div class="h-1/2 flex gap-6">

          <!-- Bottom-Left: Network Charts (Swapped) -->
          <div class="w-2/3 flex flex-col gap-3">
             <div class="flex-1 liquid-glass rounded-2xl p-2 relative">
               <canvas id="net1Chart"></canvas>
               <div class="absolute top-2 left-3 text-[10px] bg-slate-900/80 px-1.5 rounded text-slate-400 font-mono" id="net1-label">NIC 1</div>
             </div>
             <div class="flex-1 liquid-glass rounded-2xl p-2 relative">
               <canvas id="net2Chart"></canvas>
               <div class="absolute top-2 left-3 text-[10px] bg-slate-900/80 px-1.5 rounded text-slate-400 font-mono" id="net2-label">NIC 2</div>
             </div>
          </div>
          
          <!-- Bottom-Left: CPU/RAM Bars -->
          <div class="w-1/3 liquid-glass rounded-2xl p-4 flex justify-center gap-12 items-end">
             <!-- CPU Bar Group -->
             <div class="flex flex-col items-center gap-2 h-full justify-end w-12">
               <div class="text-xs font-bold text-slate-300 mb-1" id="cpu-text">0%</div>
               <div class="w-full bg-slate-700/50 rounded-lg relative flex-1 overflow-hidden group">
                 <div id="cpu-bar" class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-blue-600 to-cyan-400 transition-all duration-700 rounded-lg" style="height: 0%"></div>
                 <!-- CPU Temp Overlay -->
                 <div class="absolute bottom-2 w-full text-center">
                    <span id="cpu-temp" class="text-[9px] font-bold text-white drop-shadow-md">--째C</span>
                 </div>
               </div>
               <div class="mt-2 text-xs text-slate-400 font-medium">CPU</div>
             </div>

             <!-- RAM Bar Group -->
             <div class="flex flex-col items-center gap-2 h-full justify-end w-20">
               <div class="text-xs font-bold text-slate-300 mb-1" id="ram-text">0%</div>
               <div class="w-12 bg-slate-700/50 rounded-lg relative flex-1 overflow-hidden flex flex-col-reverse group">
                 <!-- Stacked Bars: Bottom is Apps, Top is Cache -->
                 <!-- User requested specific two-color gradient style like CPU. -->
                 <!-- Since stacked, we use variants of the same theme or distinct gradients that look unified. -->
                 <!-- Labels text should be always visible (no opacity-0) -->
                 <div id="ram-bar-apps" class="w-full bg-gradient-to-t from-purple-800 to-purple-500 transition-all duration-700 rounded-b-lg relative" style="height: 0%">
                    <span class="absolute bottom-1 w-full text-center text-[9px] text-white drop-shadow-md font-bold">App</span>
                 </div>
                 <div id="ram-bar-cache" class="w-full bg-gradient-to-t from-cyan-600 to-cyan-400 transition-all duration-700 rounded-t-lg backdrop-blur-sm relative" style="height: 0%">
                    <span class="absolute bottom-1 w-full text-center text-[9px] text-white drop-shadow-md font-bold">ZFS</span>
                 </div>
               </div>
               <div class="mt-2 text-xs text-slate-400 font-medium">RAM</div>
             </div>
          </div>

        </div>
      </section>

    </main>

    <script>
      // -- DOM Elements --
      const uptimeDisplay = document.getElementById("uptime-display");
      const storageContainer = document.getElementById("storage-container");
      
      const cpuBar = document.getElementById("cpu-bar");
      const cpuText = document.getElementById("cpu-text");
      
      // Split RAM Bars
      const ramBarApps = document.getElementById("ram-bar-apps");
      const ramBarCache = document.getElementById("ram-bar-cache");
      const ramText = document.getElementById("ram-text");

      const net1Label = document.getElementById("net1-label");
      const net2Label = document.getElementById("net2-label");
      const bgIpDecoration = document.getElementById("bg-ip-decoration");

      // -- Sidebar Folders Logic --
      function toggleGroup(listId, btn) {
          const list = document.getElementById(listId);
          if (!list) return;
          
          const isHidden = list.classList.contains('max-h-0');
          
          // Collapse others (Accordion effect)
          document.querySelectorAll('.app-list-container').forEach(el => {
              if (el.id !== listId) {
                  el.classList.add('max-h-0', 'opacity-0');
                  el.classList.remove('max-h-[800px]', 'opacity-100', 'pb-4', 'pt-2');
                  
                  // Reset button styles of others
                  const otherBtn = el.previousElementSibling;
                  if (otherBtn && otherBtn.classList.contains('folder-btn')) {
                      otherBtn.classList.remove('bg-slate-700', 'text-white', 'border-slate-500/50');
                      otherBtn.classList.add('bg-slate-800/60', 'text-slate-400');
                  }
              }
          });

          if (isHidden) {
              list.classList.remove('max-h-0', 'opacity-0');
              list.classList.add('max-h-[800px]', 'opacity-100', 'pb-4', 'pt-2'); // Added padding top/bottom to prevent clip
              btn.classList.add('bg-slate-700', 'text-white', 'border-slate-500/50');
              btn.classList.remove('bg-slate-800/60', 'text-slate-400');
          } else {
              list.classList.add('max-h-0', 'opacity-0');
              list.classList.remove('max-h-[800px]', 'opacity-100', 'pb-4', 'pt-2');
              btn.classList.remove('bg-slate-700', 'text-white', 'border-slate-500/50');
              btn.classList.add('bg-slate-800/60', 'text-slate-400');
          }
      }

      // -- Tooltip Logic --
      const globalTooltip = document.createElement('div');
      globalTooltip.className = 'fixed hidden px-2 py-1 bg-slate-900/90 text-slate-200 text-xs font-bold rounded shadow-xl border border-white/10 backdrop-blur-md z-[9999] pointer-events-none whitespace-nowrap transition-opacity duration-200';
      document.body.appendChild(globalTooltip);

      // Arrow
      const arrow = document.createElement('div');
      arrow.className = 'absolute right-full top-1/2 -translate-y-1/2 border-4 border-transparent border-r-slate-900/90';
      // Do not append yet, will clear content

      function showTooltip(e) {
          const target = e.target.closest('[data-tooltip]');
          if (!target) return;

          const text = target.getAttribute('data-tooltip');
          if (!text) return;

          globalTooltip.textContent = text;
          globalTooltip.appendChild(arrow);

          globalTooltip.classList.remove('hidden');
          // Force layout reflow?
          void globalTooltip.offsetWidth;
          globalTooltip.classList.add('opacity-100');

          const rect = target.getBoundingClientRect();
          const top = rect.top + (rect.height / 2) - (globalTooltip.offsetHeight / 2);
          const left = rect.right + 12;

          globalTooltip.style.top = `${top}px`;
          globalTooltip.style.left = `${left}px`;
      }

      function hideTooltip() {
          globalTooltip.classList.remove('opacity-100');
          globalTooltip.classList.add('hidden');
      }

      document.addEventListener('mouseover', (e) => {
          if (e.target.closest('[data-tooltip]')) {
              showTooltip(e);
          } else {
              hideTooltip();
          }
      });
      
      // Add dedicated mouseout specifically for targets to ensure it clears
      document.addEventListener('mouseout', (e) => {
          const target = e.target.closest('[data-tooltip]');
          if (target) {
             // We verify if we are moving to child element?
             // Mouseout fires when entering child.
             // relatedTarget tells us where we went.
             if (!target.contains(e.relatedTarget)) {
                 hideTooltip();
             }
          }
      });
      
      // -- Helpers --
      function formatBits(value) {
        if (value === null || value === undefined || Number.isNaN(value)) value = 0;
        value = value * 8; // Convert Bytes to Bits
        const units = ["b", "kb", "Mb", "Gb", "Tb"]; // Lowercase 'b' for bits
        let size = Number(value);
        let unitIndex = 0;
        while (size >= 1000 && unitIndex < units.length - 1) { // 1000 for network decimals usually, keeping 1024 for data is ok but bits usually base 10
            size /= 1000;
            unitIndex += 1;
        }
        return `${size.toFixed(1)} ${units[unitIndex]}`;
      }

      function formatBytes(value) {
        if (value === null || value === undefined || Number.isNaN(value)) return "0 B";
        const units = ["B", "KB", "MB", "GB", "TB"];
        let size = Number(value);
        let unitIndex = 0;
        while (size >= 1024 && unitIndex < units.length - 1) {
          size /= 1024;
          unitIndex += 1;
        }
        return `${size.toFixed(1)} ${units[unitIndex]}`;
      }
      
      function formatFromGiB(value) {
          if (!value) return "0 GiB";
          if (value > 1024) return `${(value/1024).toFixed(1)} TiB`;
          return `${value.toFixed(1)} GiB`;
      }

      function formatRate(value) {
        return `${formatBits(value)}/s`;
      }

      // -- Charts --
      const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        scales: {
            x: { display: false },
            y: { 
                display: true, // Show Y axis
                beginAtZero: true,
                ticks: {
                    color: '#64748b', // slate-500
                    font: { size: 9 },
                    callback: function(value) { return formatBits(value) + '/s'; }
                },
                grid: {
                    color: 'rgba(255, 255, 255, 0.05)'
                }
            }
        },
        plugins: {
            legend: { display: false },
            tooltip: { enabled: false }
        },
        elements: {
            point: { radius: 0 },
            line: { tension: 0.4, borderWidth: 2 }
        }
      };

      // Initialize Network Charts
      const net1ctx = document.getElementById('net1Chart').getContext('2d');
      const net2ctx = document.getElementById('net2Chart').getContext('2d');

      const createNetChart = (ctx, color1, color2) => new Chart(ctx, {
          type: 'line',
          data: {
              labels: Array(30).fill(''),
              datasets: [
                  { label: 'In', data: Array(30).fill(0), borderColor: color1, borderWidth: 1.5, fill: false }, // Rx
                  { label: 'Out', data: Array(30).fill(0), borderColor: color2, borderWidth: 1.5, fill: false } // Tx
              ]
          },
          options: chartOptions
      });

      const chart1 = createNetChart(net1ctx, '#34d399', '#38bdf8'); // Green In, Blue Out
      const chart2 = createNetChart(net2ctx, '#34d399', '#38bdf8');

      // -- Render Logic --

      function getDiskIcon(diskType) {
          if (diskType === 'NVMe') return 'fa-memory';
          if (diskType === 'SSD') return 'fa-hard-drive'; // Same icon, maybe style differs?
          return 'fa-hard-drive';
      }

      function renderDisks(disks) {
          const hddList = document.getElementById("hdd-list");
          const ssdList = document.getElementById("ssd-list");
          
          if (!hddList || !ssdList) return;
          
          hddList.innerHTML = "";
          ssdList.innerHTML = "";

          if (!disks || disks.length === 0) {
              hddList.innerHTML = '<div class="text-slate-500 text-xs italic">No HDD</div>';
              ssdList.innerHTML = '<div class="text-slate-500 text-xs italic">No SSD</div>';
              return;
          }

          disks.forEach(disk => {
              const temp = disk.temp;
              const sizeStr = formatFromGiB(disk.size / (1024**3));
              const typeLabel = disk.type;
              
              // Sort into columns
              const targetList = (disk.type === 'HDD') ? hddList : ssdList;

              // Temp Color Logic
              let tempClass = "text-emerald-400";
              if (temp > 40) tempClass = "text-yellow-400";
              if (temp > 50) tempClass = "text-rose-400";
              if (temp === null || temp === undefined) tempClass = "text-slate-500";
              const tempDisplay = (temp !== null && temp !== undefined) ? `${temp}째C` : "--";

              const div = document.createElement("div");
              div.className = "bg-slate-800/40 p-2 rounded-lg flex items-center justify-between group hover:bg-slate-700/40 transition border border-white/5 box-shadow-inner backdrop-blur-sm";
              div.innerHTML = `
                  <div class="flex items-center gap-2 overflow-hidden">
                       <div class="w-8 h-8 rounded-full bg-slate-700/50 flex items-center justify-center shrink-0">
                          <i class="fa-solid ${getDiskIcon(disk.type)} text-slate-400 text-xs"></i>
                       </div>
                       <div class="min-w-0">
                           <div class="text-xs font-bold text-slate-200 truncate">${disk.name}</div>
                           <div class="text-[9px] text-slate-500 truncate" title="${disk.model}">${disk.model}</div>
                       </div>
                  </div>
                  <div class="text-right whitespace-nowrap shrink-0 pl-1">
                      <div class="text-xs font-bold ${tempClass}">${tempDisplay}</div>
                      <div class="text-[9px] text-slate-500">${sizeStr}</div>
                  </div>
              `;
              targetList.appendChild(div);
          });
          
          // Empty states
          if (hddList.childElementCount === 0) hddList.innerHTML = '<div class="text-slate-600 text-[10px] italic p-2 text-center">No HDDs found</div>';
          if (ssdList.childElementCount === 0) ssdList.innerHTML = '<div class="text-slate-600 text-[10px] italic p-2 text-center">No SSDs found</div>';
      }

      function updateBar(barEl, textEl, percentage) {
          const val = percentage || 0;
          barEl.style.height = `${val}%`;
          if (textEl) textEl.textContent = `${Math.round(val)}%`;
          
          // Color shift based on load (Only if it has standard gradient logic)
          // Since we moved to stacked bars for RAM, this applies mostly to CPU now
          if (barEl.id === 'cpu-bar') {
                barEl.classList.remove('from-blue-600', 'to-cyan-400', 'from-amber-600', 'to-yellow-400', 'from-rose-600', 'to-red-400');
                if (val > 80) {
                    barEl.classList.add('from-rose-600', 'to-red-400');
                } else if (val > 60) {
                    barEl.classList.add('from-amber-600', 'to-yellow-400');
                } else {
                    barEl.classList.add('from-blue-600', 'to-cyan-400');
                }
          }
      }

      function updateRamStacked(appPercent, cachePercent, textEl) {
         const appP = appPercent || 0;
         const cacheP = cachePercent || 0;
         const totalUsed = appP + cacheP;

         if (ramBarApps) ramBarApps.style.height = `${appP}%`;
         if (ramBarCache) ramBarCache.style.height = `${cacheP}%`;
         
         if (textEl) textEl.textContent = `${Math.round(totalUsed)}%`;
      }

      function renderStorage(disks) {
        storageContainer.innerHTML = "";
        
        if (!disks || disks.length === 0) {
            storageContainer.innerHTML = '<div class="text-slate-500">No Storage Data</div>';
            return;
        }

        disks.forEach((disk) => {
          const percentVal = disk.used_percent || 0;
          const percentage = percentVal.toFixed(1);

          let colorHex = "#10b981"; 
          if (percentVal > 75) colorHex = "#f59e0b";
          if (percentVal > 90) colorHex = "#f43f5e";
          
          const chartConic = `background: conic-gradient(${colorHex} ${percentVal}%, #1e293b 0);`; // #1e293b is slate-800

          const div = document.createElement("div");
          div.className = "flex flex-col items-center justify-center flex-1 w-full";
          // Large responsive donut
          // h-[240px] w-[240px] fixed or responsive? Let's use relative sizing valid safely within container
          div.innerHTML = `
             <div class="relative h-[25vh] aspect-square rounded-full shadow-2xl flex items-center justify-center transition-all duration-300 hover:scale-105" style="${chartConic}">
                <div class="absolute inset-[15%] bg-slate-950 rounded-full flex flex-col items-center justify-center pt-2">
                   <div class="text-3xl lg:text-4xl font-bold text-slate-100 tracking-tighter">${percentage}%</div>
                   <div class="text-xs text-emerald-400 font-bold uppercase tracking-widest mt-1">Online</div>
                </div>
             </div>
             <div class="mt-4 text-center">
                 <h3 class="text-xl font-medium text-slate-200">${disk.label.split(' ')[0]}</h3>
                 <p class="text-sm text-slate-400 font-mono mt-1">${formatFromGiB(disk.used)} / ${formatFromGiB(disk.total)}</p>
             </div>
          `;
          storageContainer.appendChild(div);
        });
      }

      function updateChartData(chart, rx, tx) {
          // Push new data
          chart.data.datasets[0].data.push(rx);
          chart.data.datasets[1].data.push(tx);
          // Remove old
          if (chart.data.datasets[0].data.length > 30) {
              chart.data.datasets[0].data.shift();
              chart.data.datasets[1].data.shift();
          }
          chart.update();
      }

      // -- Fetchers --

      async function fetchMetrics() {
        try {
          const response = await fetch("/api/metrics");
          const data = await response.json();
          
          // Update Background IP if not set or changed
          if (data.system_ip && bgIpDecoration) {
             bgIpDecoration.textContent = data.system_ip.split(":")[0]; // Just IP no port if any
          }

          // Storage
          renderStorage(data.disks);

          // CPU / RAM Bars
          updateBar(cpuBar, cpuText, data.cpu_usage);
          
          const cpuTempEl = document.getElementById('cpu-temp');
          if (cpuTempEl) {
              const t = data.cpu_temp;
              cpuTempEl.textContent = (t !== null && t !== undefined) ? `${Math.round(t)}째C` : '--째C';
          }
          
          if (data.memory) {
             updateRamStacked(data.memory.apps_percent, data.memory.cache_percent, ramText);
          } else {
             // Fallback
             updateRamStacked(0, 0, ramText);
          }

          // Network Charts
          if (data.nets && data.nets.length >= 2) {
             const net1 = data.nets[0];
             const net2 = data.nets[1];
             
             // Update Labels
             net1Label.innerText = `${net1.label} (Rx: ${formatRate(net1.rx)})`;
             net2Label.innerText = `${net2.label} (Rx: ${formatRate(net2.rx)})`;

             updateChartData(chart1, net1.rx, net1.tx);
             updateChartData(chart2, net2.rx, net2.tx);
          } else if (data.nets && data.nets.length >= 1) {
             const net1 = data.nets[0];
             net1Label.innerText = `${net1.label} (Rx: ${formatRate(net1.rx)})`;
             updateChartData(chart1, net1.rx, net1.tx);
          }

        } catch (error) {
           console.error("Metric fetch fail", error);
        }
      }

      async function fetchStats() {
          try {
            const response = await fetch("/api/stats");
            const data = await response.json();
            
            if(data.uptime) {
                // Convert seconds to readable string roughly
                const uptime = data.uptime; 
                if (typeof uptime === 'number') {
                    const days = Math.floor(uptime / 86400);
                    const hours = Math.floor((uptime % 86400) / 3600);
                    uptimeDisplay.textContent = `Uptime: ${days}d ${hours}h`;
                } else {
                    uptimeDisplay.textContent = `Uptime: ${uptime}`; 
                }
            }

            // Render Disks
            if (data.disks) {
                renderDisks(data.disks);
            }

          } catch(e) { console.error(e); }
      }

      // Initial Calls
      fetchStats();
      fetchMetrics();
      
      setInterval(fetchStats, 10000);
      setInterval(fetchMetrics, 2000); // Faster visual refresh for charts
    </script>
  </body>
</html>

